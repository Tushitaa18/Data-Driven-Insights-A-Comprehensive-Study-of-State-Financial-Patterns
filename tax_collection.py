# -*- coding: utf-8 -*-
"""Tax Collection.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Q3zZMbymkhKZcCoEW7gatXuF0UVXvn7-
"""

import seaborn as sns
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

from google.colab import drive
drive.mount('/content/drive')

file_path = '/content/drive/MyDrive/Tax Collection.csv'
try:

    df = pd.read_csv(file_path)
    print("File loaded successfully.")
except Exception as e:
    print(f"An error occurred: {e}")

file_path = '/content/drive/MyDrive/Revenue Expenditure.csv'
try:

    df12 = pd.read_csv(file_path)
    print("File loaded successfully.")
except Exception as e:
    print(f"An error occurred: {e}")

df.columns = df.columns.str.strip()

df12.columns = df12.columns.str.strip()

# Set pandas display options to show all columns
pd.set_option('display.max_columns', None)

df12.head()

import pandas as pd

# Assuming df12 is your original DataFrame

# List of agriculture-related columns
agriculture_columns = [
    'srcStateName',	'YearCode',	'Budget type',
    'Agriculture and allied activities',
    'Crop husbandry',
    'Soil and water conservation',
    'Animal husbandry',
    'Dairy development',
    'Fisheries',
    'Forestry and wild life',
    'Plantations',
    'Food storage and Warehousing',
    'Agricultural research and education',
    'Agricultural finance institutions',
    'Cooperation',
    'Other agricultural programmes'
]

# Create a new DataFrame with only these columns
df_agriculture = df12[agriculture_columns]

df_agriculture.head()

# Filter rows where 'Budget type' is 'Accounts' and 'srcStateName' is in the specified list
df_Agri = df_agriculture[(df_agriculture['Budget type'] == 'Accounts') &
                             (df_agriculture['srcStateName'].isin(['PUNJAB', 'HARYANA', 'BIHAR']))]

df.head()

# Filter rows where 'Budget type' is 'Accounts' and 'srcStateName' is in the list of states
states = ['HARYANA', 'PUNJAB', 'BIHAR']
df_filtered = df[df['Budget type'] == 'Accounts']
df_filtered = df_filtered[df_filtered['srcStateName'].isin(states)]

# Keep only the 'srcStateName', 'YearCode', and 'Agricultural income' columns
df_final = df_filtered[['srcStateName', 'YearCode', 'Agricultural income']]

# Display the result
df_final.head()

df_final_cleaned = df_final.dropna(subset=['Agricultural income'])

# Display the result
df_final_cleaned.head()

df_Agri.head()

import matplotlib.pyplot as plt
import seaborn as sns

# Select the relevant columns for correlation
df_corr = df_Agri[['Agriculture and allied activities', 'Agricultural research and education']]

# Calculate the correlation matrix
corr_matrix = df_corr.corr()

# Plot the correlation matrix using a heatmap
plt.figure(figsize=(6, 4))
sns.heatmap(corr_matrix, annot=True, cmap='coolwarm', fmt='.2f', vmin=-1, vmax=1, linewidths=1)

# Customize the plot
plt.title('Correlation between Agriculture and Allied Activities and Agricultural Research and Education')
plt.tight_layout()

# Show the plot
plt.show()

import matplotlib.pyplot as plt
import seaborn as sns

# Set the aesthetic style of the plots
sns.set(style="whitegrid")

# Plot the 'Agriculture and allied activities' over the years for each state
plt.figure(figsize=(10,6))
sns.lineplot(data=df_Agri, x="YearCode", y="Agriculture and allied activities", hue="srcStateName", marker="o")

# Customize the plot
plt.title('Agriculture and Allied Activities Over the Years')
plt.xlabel('Year')
plt.ylabel('Expenditure')
plt.xticks(rotation=45)
plt.legend(title='State')

plt.tight_layout()
plt.show()

# For example, comparing 'Agriculture and allied activities' for 2015 across states
df_2015 = df_Agri[df_Agri['YearCode'] == 2015]

plt.figure(figsize=(10,6))
sns.barplot(data=df_2015, x="srcStateName", y="Agriculture and allied activities", palette="viridis")

# Customize the plot
plt.title('Agriculture and Allied Activities in 2015 by State')
plt.xlabel('State')
plt.ylabel('Expenditure')
plt.xticks(rotation=45)

plt.tight_layout()
plt.show()

# Correlation matrix of the selected columns
corr = df_Agri[['Agriculture and allied activities', 'Crop husbandry', 'Soil and water conservation',
                'Animal husbandry', 'Dairy development', 'Fisheries', 'Forestry and wild life',
                'Plantations', 'Food storage and Warehousing', 'Agricultural research and education',
                'Agricultural finance institutions', 'Cooperation', 'Other agricultural programmes']].corr()

# Plotting the heatmap
plt.figure(figsize=(12,8))
sns.heatmap(corr, annot=True, cmap='coolwarm', fmt=".2f", linewidths=0.5)

# Customize the plot
plt.title('Correlation Heatmap of Agricultural Expenditures')
plt.tight_layout()
plt.show()

# Boxplot of 'Agriculture and allied activities' expenditures by state
plt.figure(figsize=(12,6))
sns.boxplot(data=df_Agri, x="srcStateName", y="Agriculture and allied activities", palette="Set2")

# Customize the plot
plt.title('Distribution of Agriculture and Allied Activities Expenditures by State')
plt.xlabel('State')
plt.ylabel('Expenditure')
plt.xticks(rotation=45)

plt.tight_layout()
plt.show()

# Example: Breakdown of 'Agriculture and allied activities' for the year 2015
df_2015_expenditure = df_Agri[df_Agri['YearCode'] == 2015].sum()

# Selecting relevant columns
expenditure_columns = ['Agriculture and allied activities', 'Crop husbandry', 'Soil and water conservation',
                       'Animal husbandry', 'Dairy development', 'Fisheries']

# Plotting a pie chart for the selected expenditure columns
plt.figure(figsize=(8,8))
df_2015_expenditure[expenditure_columns].plot.pie(autopct='%1.1f%%', startangle=90, cmap='Set3')

# Customize the plot
plt.title('Expenditure Breakdown in 2015 for Agricultural Activities')
plt.ylabel('')  # Remove the ylabel for aesthetic reasons

plt.tight_layout()
plt.show()

# Create a unique 'state_id' for each unique 'srcStateName'
state_mapping = {state: idx for idx, state in enumerate(df['srcStateName'].unique(), start=1)}

# Assign the 'state_id' to a new column in the DataFrame
df['state_id'] = df['srcStateName'].map(state_mapping)

# Print the updated DataFrame to check the 'state_id' column
print(df[['srcStateName', 'state_id']].head())

# Inspect the first few rows
df.head()

df4 = df[df['Budget type'] == 'Accounts']

df4.head()

import seaborn as sns
import matplotlib.pyplot as plt

# Create a FacetGrid for the 'Tourism' data by 'srcStateName'
g = sns.FacetGrid(df4, col="srcStateName", col_wrap=4, height=4, sharey=False)

# Map the 'sns.lineplot' to plot 'Year' vs 'Tourism' in each facet
g.map(sns.lineplot, "Year", "Tourism", marker='o')

# Customize the plot titles and axes
g.set_titles("{col_name}")
g.set_axis_labels("Year", "Tourism Revenue")

# Rotate x-axis labels for better readability
for ax in g.axes.flat:
    ax.set_xticklabels(ax.get_xticklabels(), rotation=45)

# Adjust layout for better space distribution
plt.tight_layout()
plt.show()

# Check for missing values
missing_values = df.isnull().sum()
print("Missing Values:\n", missing_values)

# Check for missing values (count of NaNs)
missing_values = df.isnull().sum()

# Calculate the percentage of missing values for each column
missing_percentage = (missing_values / len(df)) * 100

# Combine count and percentage into a DataFrame for easier viewing
missing_summary = pd.DataFrame({
    'Missing Values Count': missing_values,
    'Missing Values Percentage': missing_percentage
})

# Sort the DataFrame by the count of missing values in descending order
missing_summary = missing_summary.sort_values(by='Missing Values Count', ascending=False)

# Print the missing values summary
print("Missing Values Summary:\n", missing_summary)

# Check for missing values (count of NaNs)
missing_values = df.isnull().sum()

# Calculate the percentage of missing values for each column
missing_percentage = (missing_values / len(df)) * 100

# Combine count and percentage into a DataFrame for easier viewing
missing_summary = pd.DataFrame({
    'Missing Values Count': missing_values,
    'Missing Values Percentage': missing_percentage
})

# Sort the DataFrame by the count of missing values in descending order
missing_summary = missing_summary.sort_values(by='Missing Values Count', ascending=False)

# Print the missing values summary
print("Missing Values Summary:\n", missing_summary)

# Remove columns where more than 20% of the values are missing
threshold = 20  # percentage threshold for missing values
columns_to_remove = missing_percentage[missing_percentage > threshold].index

# Create a new DataFrame by dropping the columns with more than 20% missing values
df2 = df.drop(columns=columns_to_remove)

# Print the shape of the new DataFrame
print(f"Original DataFrame shape: {df.shape}")
print(f"New DataFrame shape after removing columns with > 20% missing values: {df2.shape}")

# Create a unique 'state_id' for each unique 'srcStateName'
state_mapping = {state: idx for idx, state in enumerate(df2['srcStateName'].unique(), start=1)}

# Assign the 'state_id' to a new column in the DataFrame
df2['state_id'] = df2['srcStateName'].map(state_mapping)

# Print the updated DataFrame to check the 'state_id' column
print(df2[['srcStateName', 'state_id']].head())

columns_to_move = ['state_id', 'Year', 'YearCode']

# Get the remaining columns (excluding 'state_id', 'Year', and 'YearCode')
remaining_columns = [col for col in df2.columns if col not in columns_to_move]

# Create the new column order by concatenating the columns to move and the remaining columns
new_column_order = columns_to_move + remaining_columns

# Reorder the columns in the DataFrame
df2 = df2[new_column_order]

# Sort the DataFrame by 'state_id' and then by 'YearCode' in ascending order
df2 = df2.sort_values(by=['state_id', 'YearCode'], ascending=[True, True])

# Reset index after sorting (optional)
df2 = df2.reset_index(drop=True)

df2.head()

df3 = df2[df2['Budget type'] == 'Accounts']

df3.head()

import seaborn as sns
import matplotlib.pyplot as plt

# Create a Seaborn line plot for 'Tourism' vs 'Year' for each 'srcStateName'
plt.figure(figsize=(12, 6))
sns.lineplot(data=df3, x='YearCode', y='Tourism', hue='srcStateName', marker='o')

# Customize plot
plt.title('Tourism Revenue by State over Years')
plt.xlabel('Year')
plt.ylabel('Tourism Revenue')
plt.xticks(rotation=45)  # Rotate the x-axis labels if necessary
plt.legend(title='State', bbox_to_anchor=(1.05, 1), loc='upper left')  # Place legend outside the plot

# Display the plot
plt.tight_layout()
plt.show()

# Find the row with the highest Tourism revenue
max_tourism_row = df3.loc[df3['Tourism'].idxmax()]

# Extract the state and tourism value
max_tourism_state = max_tourism_row['srcStateName']
max_tourism_value = max_tourism_row['Tourism']
max_tourism_year = max_tourism_row['Year']

# Print the state with the highest tourism revenue
print(f"The state with the highest Tourism revenue is {max_tourism_state} in the year {max_tourism_year} with a revenue of {max_tourism_value:.2f}")

import pandas as pd

# Assuming df3 is already loaded into the environment

# Filter the data for Gujarat state
gujarat_data = df3[df3['srcStateName'] == 'GUJARAT']

# Check the unique YearCode values for Gujarat to see what format they are in
print(gujarat_data['YearCode'].unique())  # This will print all unique YearCode values for Gujarat

# Convert 'YearCode' to string to avoid the .str accessor issue
gujarat_data['YearCode'] = gujarat_data['YearCode'].astype(str)

# Now, filter the Gujarat data for the years 2017, 2018, and 2019
gujarat_2017_18 = gujarat_data[gujarat_data['YearCode'] == '2017']
gujarat_2018_19 = gujarat_data[gujarat_data['YearCode'] == '2018']
gujarat_2019_20 = gujarat_data[gujarat_data['YearCode'] == '2019']

# Check if data exists for these years
if gujarat_2017_18.empty:
    print("No data available for Gujarat in 2017.")
else:
    revenue_2017_18 = gujarat_2017_18['Tourism'].values[0]
    print(f"Tourism Revenue for Gujarat in 2017: {revenue_2017_18}")

if gujarat_2018_19.empty:
    print("No data available for Gujarat in 2018.")
else:
    revenue_2018_19 = gujarat_2018_19['Tourism'].values[0]
    print(f"Tourism Revenue for Gujarat in 2018: {revenue_2018_19}")

if gujarat_2019_20.empty:
    print("No data available for Gujarat in 2019.")
else:
    revenue_2019_20 = gujarat_2019_20['Tourism'].values[0]
    print(f"Tourism Revenue for Gujarat in 2019: {revenue_2019_20}")

# If all years have data, calculate the percentage differences
if not gujarat_2017_18.empty and not gujarat_2018_19.empty:
    percentage_diff_17_18_to_18_19 = ((revenue_2018_19 - revenue_2017_18) / revenue_2017_18) * 100
    print(f"Percentage difference in Tourism Revenue from 2017 to 2018: {percentage_diff_17_18_to_18_19:.2f}%")

if not gujarat_2018_19.empty and not gujarat_2019_20.empty:
    percentage_diff_18_19_to_19_20 = ((revenue_2019_20 - revenue_2018_19) / revenue_2018_19) * 100
    print(f"Percentage difference in Tourism Revenue from 2018 to 2019: {percentage_diff_18_19_to_19_20:.2f}%")

if not gujarat_2017_18.empty and not gujarat_2019_20.empty:
    percentage_diff_17_18_to_19_20 = ((revenue_2019_20 - revenue_2017_18) / revenue_2017_18) * 100
    print(f"Percentage difference in Tourism Revenue from 2017 to 2019: {percentage_diff_17_18_to_19_20:.2f}%")

import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt

# Assuming df3 is already loaded into the environment

# Filter the data for Madhya Pradesh state
mp_data = df3[df3['srcStateName'] == 'MADHYA PRADESH']

# Check the unique YearCode values for Madhya Pradesh to see what format they are in
print(mp_data['YearCode'].unique())  # This will print all unique YearCode values for Madhya Pradesh

# Convert 'YearCode' to string to avoid the .str accessor issue (if necessary)
mp_data['YearCode'] = mp_data['YearCode'].astype(str)

# Now, filter the Madhya Pradesh data for the years 2015 and 2016
mp_2015 = mp_data[mp_data['YearCode'] == '2015']
mp_2016 = mp_data[mp_data['YearCode'] == '2016']

# Check if data exists for these years
if mp_2015.empty:
    print("No data available for Madhya Pradesh in 2015.")
else:
    revenue_2015 = mp_2015['Tourism'].values[0]
    print(f"Tourism Revenue for Madhya Pradesh in 2015: {revenue_2015}")

if mp_2016.empty:
    print("No data available for Madhya Pradesh in 2016.")
else:
    revenue_2016 = mp_2016['Tourism'].values[0]
    print(f"Tourism Revenue for Madhya Pradesh in 2016: {revenue_2016}")

# If both years have data, calculate the percentage difference
if not mp_2015.empty and not mp_2016.empty:
    percentage_diff_15_to_16 = ((revenue_2016 - revenue_2015) / revenue_2015) * 100
    print(f"Percentage difference in Tourism Revenue from 2015 to 2016: {percentage_diff_15_to_16:.2f}%")

"""Based on the data analysis, Madhya Pradesh's tourism revenue in 2015 was 2,064 crore INR, which significantly rose to 8,918 crore INR in 2016, reflecting a remarkable growth rate of 332.07%. This substantial increase in tourism revenue is aligned with the state’s targeted goal of boosting tourism, and it highlights the successful impact of both the government’s efforts and external factors driving tourism growth.

Link with Government Policy to Promote Tourism
Madhya Pradesh's Tourism Growth Target (2016): In 2016, the Madhya Pradesh government aimed for a 15% growth in tourist arrivals from the previous year (2015), targeting a total of 7.5 crore tourists. This growth target stemmed from various government efforts, including investments in tourism infrastructure and promotional campaigns.

Reasons for Growth: The state's robust growth in tourism in 2016, far exceeding the initial 15% growth target, can be attributed to several strategic initiatives:

Improved Infrastructure: Key upgrades in transportation networks, connectivity, and the development of tourism-related infrastructure played a pivotal role in attracting more visitors.
Government Campaigns: The state ran marketing campaigns targeting both domestic and international tourists, highlighting its rich historical, cultural, and wildlife offerings.
Diversified Tourism Offerings: Beyond traditional cultural tourism, Madhya Pradesh also emphasized its potential in adventure tourism, wildlife safaris, and spiritual tourism, drawing a diverse audience.
Madhya Pradesh Tourism Policy 2016: The Madhya Pradesh Tourism Policy 2016 aimed to establish the state as a leading tourism hub in India. Key objectives of the policy included:

Enhancing Infrastructure: The policy prioritized the development of better roads, transportation, and tourist facilities to make the state more accessible and tourist-friendly.
Sustainable and Eco-friendly Tourism: It encouraged sustainable tourism practices, focusing on preserving the state’s natural resources and cultural heritage.
Promotion & Diversification: By promoting a broader array of tourism activities, the policy aimed to increase tourist traffic and extend the stay of visitors. Attractions like Khajuraho Temples, Sanchi Stupa, and the national parks were marketed globally.
Establishment of Madhya Pradesh Tourism Board (MPTB): In 2017, the state created the Madhya Pradesh Tourism Board (MPTB) to streamline tourism development and promotion. The MPTB worked to:

Boost Global Visibility: Through international marketing campaigns, the MPTB sought to position Madhya Pradesh as a premier tourist destination.
Collaborate with Private Sector: The board also fostered partnerships with the private sector, improving tourist services and infrastructure.
Impact of Government Policies:

The growth in tourism revenue aligns with the government’s economic objectives, aiming to increase tourism revenue, create jobs, and boost local businesses.
The tourism sector’s development also significantly contributed to the state’s cultural heritage preservation, with increased attention given to UNESCO World Heritage sites.
The tourism policies promoted economic growth by attracting both domestic and international tourists, making tourism a vital contributor to Madhya Pradesh’s economy.
Final Thoughts:
The 332.07% increase in tourism revenue from 2015 to 2016 is a clear indicator that the state's tourism policies and growth strategies have been effective in stimulating the sector. The ambitious growth target for 2016 was achieved not just through government initiatives, but also because of Madhya Pradesh’s unique appeal to a variety of tourists—be it adventure seekers, history enthusiasts, or those interested in spiritual and wildlife tourism.

Looking forward, Madhya Pradesh's continued success in tourism will depend on sustaining the growth momentum, further enhancing infrastructure, and focusing on sustainable tourism that ensures long-term benefits for both the economy and the state’s cultural heritage. The state's Tourism Policy 2016, along with the Madhya Pradesh Tourism Board, provides a structured approach to achieving these goals and positioning the state as one of the top tourist destinations in India.


"""

import pandas as pd

# Assuming df3 is already loaded into the environment

# Filter the data for Gujarat state
gujarat_data = df3[df3['srcStateName'] == 'GUJARAT']

# Check the unique years available in the data
print(gujarat_data['Year'].unique())  # This will give you the exact years available for Gujarat

# Filter Gujarat data for the years 2017-18 and 2018-19
gujarat_2017_18 = gujarat_data[gujarat_data['Year'] == 2017]
gujarat_2018_19 = gujarat_data[gujarat_data['Year'] == 2018]

# Check if data exists for these years
if gujarat_2017_18.empty:
    print("No data available for Gujarat in 2017.")
else:
    revenue_2017_18 = gujarat_2017_18['Tourism'].values[0]
    print(f"Tourism Revenue for Gujarat in 2017-18: {revenue_2017_18}")

if gujarat_2018_19.empty:
    print("No data available for Gujarat in 2018.")
else:
    revenue_2018_19 = gujarat_2018_19['Tourism'].values[0]
    print(f"Tourism Revenue for Gujarat in 2018-19: {revenue_2018_19}")

# If both years have data, calculate the percentage difference
if not gujarat_2017_18.empty and not gujarat_2018_19.empty:
    percentage_diff_17_18_to_18_19 = ((revenue_2018_19 - revenue_2017_18) / revenue_2017_18) * 100
    print(f"Percentage difference in Tourism Revenue from 2017-18 to 2018-19: {percentage_diff_17_18_to_18_19:.2f}%")

"""Namaste Trump (stylised as नमस्ते TRUMP) was a tour event held on 24 and 25 February 2020 in India.[1] It was the inaugural visit of the then US President Donald Trump and his family to India.[2][3] A rally event of the same name was held in Ahmedabad, Gujarat, and was the highlight of the tour, as a response to the "Howdy Modi" event held in Houston, Texas, in September 2019.

Conclusion for Gujarat Tourism Growth and Insights:
Based on the tourism revenue data for Gujarat between 2017 and 2019, the state experienced remarkable growth in tourism revenue, indicating a successful upward trend in its tourism sector. Here's a detailed breakdown of the insights:

Tourism Revenue for Gujarat (2017-2019):
In 2017, Gujarat’s tourism revenue was 1,854 crore INR.
In 2018, tourism revenue saw an enormous jump to 9,337 crore INR, a 403.61% increase compared to 2017.
In 2019, the revenue further escalated to 27,715 crore INR, marking a 196.83% increase from 2018 and a 1394.88% increase from 2017.
This data illustrates a massive surge in tourism revenue, particularly in the span of just two years (2017–2019). The percentage increase from 2017 to 2019 is especially significant, suggesting that Gujarat’s tourism policies and initiatives, as well as international events held in the state, have played a critical role in the growth of the sector.

Link to "Namaste Trump" Event and International Exposure:
One key event that likely contributed to the surge in Gujarat's tourism revenue, particularly in 2019, is the "Namaste Trump" rally held in February 2020 in Ahmedabad, Gujarat. The event marked the inaugural visit of US President Donald Trump and his family to India, with a major rally taking place in Ahmedabad. This event brought significant international attention to Gujarat and India, leading to a boost in tourism from both international visitors and media coverage.

Key aspects that can be linked to the growth in tourism revenue:

Increased International Attention: The "Namaste Trump" rally, similar to the "Howdy Modi" event in Houston in 2019, attracted a large number of global media outlets and international dignitaries, positioning Gujarat as a prominent global tourist destination. The event likely sparked curiosity among international tourists, leading to a rise in visitors to Gujarat’s tourist sites.

Cultural and Diplomatic Influence: Hosting such a high-profile event not only raised the global profile of the state but also bolstered diplomatic and business ties between India and the US. The event underscored Gujarat’s status as an emerging hub for tourism, investment, and trade, which can have a positive impact on tourist arrivals.

Tourism-Related Infrastructure Investments: The influx of visitors for the "Namaste Trump" event highlighted the need for further investments in infrastructure, particularly in transportation, accommodations, and tourism services. This can lead to increased long-term tourism revenue as the state capitalized on its newly developed infrastructure to cater to tourists.

Symbol of Gujarat’s Economic Growth: The surge in tourism revenue from 2017 to 2019 directly correlates with the state's strategic tourism policies and international events like "Namaste Trump". The event symbolized Gujarat’s growing stature not only as a political hub but also as a tourist-friendly destination.

Insights for the Report:
The surge in tourism revenue in Gujarat can be attributed to a combination of factors, including enhanced infrastructure, better marketing, and the "Namaste Trump" event, which brought Gujarat to the international spotlight in 2019. This event provided a significant platform for promoting the state’s cultural and historical offerings to a global audience, driving increased interest and visits.

Moreover, the tourism sector's dramatic growth from 2017 to 2019—especially the 1394.88% increase from 2017 to 2019—reflects the state's effective use of international events, robust policy interventions, and strategic tourism promotion to position Gujarat as a premier tourism destination in India.

The "Namaste Trump" rally is not just a milestone in diplomacy; it played a critical role in enhancing Gujarat's tourism profile, attracting both national and international visitors, and boosting the state's tourism sector in the process.

Conclusion:
The analysis shows that Gujarat’s tourism sector has witnessed an unprecedented rise in revenue, and a significant driver of this growth appears to be international exposure, particularly through high-profile events like "Namaste Trump". The state’s tourism policy, improved infrastructure, and global attention during this period have collectively contributed to an impressive economic transformation through the tourism industry. The long-term benefits of such international exposure will likely continue to propel Gujarat’s tourism industry toward greater growth in the coming years.
"""

import seaborn as sns
import matplotlib.pyplot as plt

# Create a Seaborn line plot for 'Tourism' vs 'Year' for each 'srcStateName'
plt.figure(figsize=(12, 6))
sns.lineplot(data=df3, x='Year', y='Tourism', hue='srcStateName', marker='o')

# Customize plot
plt.title('Tourism Revenue by State over Years')
plt.xlabel('Year')
plt.ylabel('Tourism Revenue')
plt.xticks(rotation=45)  # Rotate the x-axis labels if necessary
plt.legend(title='State', bbox_to_anchor=(1.05, 1), loc='upper left')  # Place legend outside the plot

# Display the plot
plt.tight_layout()
plt.show()

# Get the top 3 rows with the highest 'Tourism' values
top_3_tourism = df3.nlargest(3, 'Tourism')

# Print the top 3 states with their tourism values
for idx, row in top_3_tourism.iterrows():
    state = row['srcStateName']
    tourism_value = row['Tourism']
    year = row['Year']
    print(f"State: {state}, Year: {year}, Tourism Revenue: {tourism_value:.2f}")

import pandas as pd

# Assuming df3 is your DataFrame
# Strip leading and trailing spaces from column names
df3.columns = df3.columns.str.strip()

# Define the list of tax-related columns (as per your request)
tax_columns = [
    'Tax revenue', 'State own tax revenue', 'Taxes on property and capital transactions',
    'Land revenue', 'Stamps and registration fees', 'Taxes on commodities and services',
    'Sales tax', 'State sales tax or Value added tax (VAT)', 'Central sales tax', 'State excise',
    'Taxes on vehicles', 'Taxes and duties on electricity', 'Entertainment tax',
    'Other taxes and duties', 'Share in central taxes', 'Corporation tax', 'Income tax',
    'Taxes on wealth', 'Customs', 'Union excise duties', 'Service tax', 'Non-tax revenue',
    'State own non-tax revenue', 'Interest receipts', 'Dividends and profits', 'General services',
    'Social services', 'Education, sports, art and culture', 'Medical and public health',
    'Housing', 'Urban development', 'Labour and employment', 'Social security and welfare',
    'Water supply and sanitation', 'Other social services taxes', 'Economic services',
    'Crop husbandry', 'Animal husbandry', 'Fisheries', 'Forestry and wildlife', 'Co-operation',
    'Other agricultural programmes', 'Major and medium irrigation projects', 'Minor irrigation',
    'Village and small industries', 'Industries', 'Tourism',
    'Grants from the centre', 'State plan schemes', 'Centrally sponsored schemes', 'Non-plan grants',
    'Statutory grants', 'Other non-plan grants'
]

# Filter the DataFrame to include only the relevant columns (srcStateName + tax-related columns)
df_tax = df3[['srcStateName'] + tax_columns]

# Sum the values across all rows (states) for each of the tax columns
tax_sums = df_tax.drop('srcStateName', axis=1).sum()

# Sort the columns by their summed values in descending order
top_10_tax_columns = tax_sums.sort_values(ascending=False).head(10)

# Display the top 10 columns with the highest values
print("Top 10 Tax Columns with Highest Values:")
print(top_10_tax_columns)

df_2011 = df3[df3['YearCode'] == 2011]
df_2011 = df3[df3['YearCode'] == 2011]
df_2012 = df3[df3['YearCode'] == 2012]
df_2013 = df3[df3['YearCode'] == 2013]
df_2014 = df3[df3['YearCode'] == 2014]
df_2015 = df3[df3['YearCode'] == 2015]
df_2016 = df3[df3['YearCode'] == 2016]
df_2017 = df3[df3['YearCode'] == 2017]
df_2018 = df3[df3['YearCode'] == 2018]
df_2019 = df3[df3['YearCode'] == 2019]

df_2011.head()



import pandas as pd
import matplotlib.pyplot as plt

# Assuming df3 is your DataFrame

# Strip leading and trailing spaces from column names to avoid issues with column names
df3.columns = df3.columns.str.strip()

# Define the list of tax-related columns (those with highest values)
tax_columns = [
    'Tax revenue', 'State own tax revenue', 'Taxes on commodities and services',
    'Non-tax revenue', 'Share in central taxes', 'Sales tax', 'State sales tax or Value added tax (VAT)',
    'Grants from the centre', 'State own non-tax revenue', 'Corporation tax'
]

# Filter the data for the year 2011 and select relevant columns (state name + tax columns)
df_2011 = df3[df3['YearCode'] == 2011][['srcStateName'] + tax_columns]

# Verify if all the tax columns exist in the DataFrame for 2011
valid_columns = [col for col in tax_columns if col in df_2011.columns]
print(f"Valid columns: {valid_columns}")  # This will give you the columns that are available in the data

# Group the data by state and aggregate the tax revenues by summing the columns
df_2011_aggregated = df_2011.groupby('srcStateName')[valid_columns].sum()

# Plot the stacked bar chart
ax = df_2011_aggregated.plot(kind='bar', stacked=True, figsize=(12, 8), colormap='tab20')

# Customize the plot with labels and title
ax.set_xlabel('State')
ax.set_ylabel('Tax Revenue (in billions or appropriate units)')
ax.set_title('Stacked Tax Revenue by State (2011)')

# Rotate x-axis labels for better readability
plt.xticks(rotation=90)

# Add a legend for better understanding of the stacked bars
ax.legend(title='Tax Categories', bbox_to_anchor=(1.05, 1), loc='upper left')

# Adjust layout to avoid cutting off labels
plt.tight_layout()

# Show the plot
plt.show()

import pandas as pd
import matplotlib.pyplot as plt

# Assuming df3 is your DataFrame

# Strip leading and trailing spaces from column names to avoid issues with column names
df3.columns = df3.columns.str.strip()

# Define the list of tax-related columns (those with highest values)
tax_columns = [
    'Tax revenue', 'State own tax revenue', 'Taxes on commodities and services',
    'Non-tax revenue', 'Share in central taxes', 'Sales tax', 'State sales tax or Value added tax (VAT)',
    'Grants from the centre', 'State own non-tax revenue', 'Corporation tax'
]

# Filter the data for the year 2011 and select relevant columns (state name + tax columns)
df_2011 = df3[df3['YearCode'] == 2011][['srcStateName'] + tax_columns]

# Verify if all the tax columns exist in the DataFrame for 2011
valid_columns = [col for col in tax_columns if col in df_2011.columns]
print(f"Valid columns: {valid_columns}")  # This will give you the columns that are available in the data

# Group the data by state and aggregate the tax revenues by summing the columns
df_2011_aggregated = df_2011.groupby('srcStateName')[valid_columns].sum()

# Calculate the percentage of each tax category relative to the total revenue for each state
df_2011_percentage = df_2011_aggregated.div(df_2011_aggregated.sum(axis=1), axis=0) * 100

# Plot the stacked bar chart
ax = df_2011_aggregated.plot(kind='bar', stacked=True, figsize=(12, 8), colormap='tab20')

# Add percentage annotations on top of each bar segment
for i, state in enumerate(df_2011_aggregated.index):
    total_height = 0
    for j, column in enumerate(valid_columns):
        percentage = df_2011_percentage.loc[state, column]
        height = df_2011_aggregated.loc[state, column]

        # Annotate each segment with the percentage value
        ax.text(i, total_height + height + 0.2,  # Adjust Y-position for visibility
                f'{percentage:.1f}%',
                ha='center', va='center', fontsize=8, color='black', fontweight='bold')

        # Update the total height for the next segment
        total_height += height

# Customize the plot with labels and title
ax.set_xlabel('State')
ax.set_ylabel('Tax Revenue (in billions or appropriate units)')
ax.set_title('Stacked Tax Revenue by State (2011)')

# Rotate x-axis labels for better readability
plt.xticks(rotation=90)

# Add a legend for better understanding of the stacked bars
ax.legend(title='Tax Categories', bbox_to_anchor=(1.05, 1), loc='upper left')

# Adjust layout to avoid cutting off labels
plt.tight_layout()

# Show the plot
plt.show()

import pandas as pd
import matplotlib.pyplot as plt

# Assuming df3 is your DataFrame

# Strip leading and trailing spaces from column names to avoid issues with column names
df3.columns = df3.columns.str.strip()

# Define the list of tax-related columns (those with highest values)
tax_columns = [
    'Tax revenue', 'State own tax revenue', 'Taxes on commodities and services',
    'Non-tax revenue', 'Share in central taxes', 'Sales tax', 'State sales tax or Value added tax (VAT)',
    'Grants from the centre', 'State own non-tax revenue', 'Corporation tax'
]

# Filter the data for the year 2011 and select relevant columns (state name + tax columns)
df_2011 = df3[df3['YearCode'] == 2011][['srcStateName'] + tax_columns]

# Verify if all the tax columns exist in the DataFrame for 2011
valid_columns = [col for col in tax_columns if col in df_2011.columns]
print(f"Valid columns: {valid_columns}")  # This will give you the columns that are available in the data

# Group the data by state and aggregate the tax revenues by summing the columns
df_2011_aggregated = df_2011.groupby('srcStateName')[valid_columns].sum()

# Calculate the percentage of each tax category relative to the total revenue for each state
df_2011_percentage = df_2011_aggregated.div(df_2011_aggregated.sum(axis=1), axis=0) * 100

# Plot the stacked bar chart
ax = df_2011_aggregated.plot(kind='bar', stacked=True, figsize=(12, 8), colormap='tab20')

# Add percentage annotations on top of each bar segment (only if percentage >= 10%)
for i, state in enumerate(df_2011_aggregated.index):
    total_height = 0
    for j, column in enumerate(valid_columns):
        percentage = df_2011_percentage.loc[state, column]
        height = df_2011_aggregated.loc[state, column]

        # Annotate each segment with the percentage value only if it's greater than or equal to 10%
        if percentage >= 10:
            ax.text(i, total_height + height + 0.2,  # Adjust Y-position for visibility
                    f'{percentage:.1f}%',
                    ha='center', va='center', fontsize=8, color='black', fontweight='bold')

        # Update the total height for the next segment
        total_height += height

# Customize the plot with labels and title
ax.set_xlabel('State')
ax.set_ylabel('Tax Revenue (in billions or appropriate units)')
ax.set_title('Stacked Tax Revenue by State (2011)')

# Rotate x-axis labels for better readability
plt.xticks(rotation=90)

# Add a legend for better understanding of the stacked bars
ax.legend(title='Tax Categories', bbox_to_anchor=(1.05, 1), loc='upper left')

# Adjust layout to avoid cutting off labels
plt.tight_layout()

# Show the plot
plt.show()

"""##Unraveling State Tax Revenue: A 2011 Perspective

Analysis of Stacked Tax Revenue by State (2011)

Overall Observations:

State Own Tax Revenue is the dominant source of revenue for most states, contributing more than 30% to the total tax revenue for states like Andhra Pradesh, Uttar Pradesh, and Gujarat.
Taxes on Commodities and Services (including Sales Tax and VAT) are also a significant source of revenue, contributing between 15% to 30% of the total tax revenue for most states.
Share in Central Taxes and Grants from the Centre are also important sources of revenue, particularly for smaller states like Himachal Pradesh and Sikkim.
State-wise Insights:

Andhra Pradesh, Uttar Pradesh, and Gujarat have the highest total tax revenue, with Andhra Pradesh leading the way. This is largely due to their strong state own tax revenue and taxes on commodities and services.
Smaller states like Himachal Pradesh and Sikkim rely heavily on grants from the centre and share in central taxes to supplement their own tax revenue.
States like Bihar and Jharkhand have relatively low tax revenue compared to other states, indicating a lower tax base and potential revenue collection challenges.
Implications for Project Report:

Policy Recommendations:
States with strong state own tax revenue and taxes on commodities and services can focus on further enhancing their tax administration and compliance mechanisms to increase revenue collection.
Smaller states can focus on improving their tax base and attracting investments to increase their own tax revenue.
The central government can consider increasing grants and share in central taxes to help smaller states with limited revenue generation capacity.
Research Directions:
A deeper analysis of the factors influencing state own tax revenue and taxes on commodities and services can be conducted.
A study on the impact of central grants and share in central taxes on state fiscal health can be undertaken.
The effectiveness of different tax administration and compliance measures in different states can be evaluated.
Additional Insights from the Stats:

Andhra Pradesh has the highest total tax revenue (approximately 40 billion units), followed by Uttar Pradesh and Gujarat.
Himachal Pradesh and Sikkim have the lowest total tax revenue, with their revenue largely coming from grants and share in central taxes.
Maharashtra has the highest state own tax revenue, followed by Andhra Pradesh and Uttar Pradesh.
Maharashtra also has the highest taxes on commodities and services, followed by Uttar Pradesh and Gujarat.
Bihar and Jharkhand have the lowest state own tax revenue and taxes on commodities and services.
Note: The specific units for tax revenue are not provided in the image.

Overall, the analysis highlights the importance of state own tax revenue and taxes on commodities and services for state finances. It also underscores the need for targeted policy interventions to address the revenue challenges faced by different states.
"""

# Filter the data for the year 2012 and select relevant columns (state name + tax columns)
df_2012 = df3[df3['YearCode'] == 2012][['srcStateName'] + tax_columns]

# Verify if all the tax columns exist in the DataFrame for 2012
valid_columns_2012 = [col for col in tax_columns if col in df_2012.columns]
print(f"Valid columns for 2012: {valid_columns_2012}")  # This will give you the columns that are available in the data

# Group the data by state and aggregate the tax revenues by summing the columns
df_2012_aggregated = df_2012.groupby('srcStateName')[valid_columns_2012].sum()

# Plot the stacked bar chart for 2012
ax = df_2012_aggregated.plot(kind='bar', stacked=True, figsize=(12, 8), colormap='tab20')

# Customize the plot with labels and title
ax.set_xlabel('State')
ax.set_ylabel('Tax Revenue (in billions or appropriate units)')
ax.set_title('Stacked Tax Revenue by State (2012)')

# Rotate x-axis labels for better readability
plt.xticks(rotation=90)

# Add a legend for better understanding of the stacked bars
ax.legend(title='Tax Categories', bbox_to_anchor=(1.05, 1), loc='upper left')

# Adjust layout to avoid cutting off labels
plt.tight_layout()

# Show the plot
plt.show()

# Filter the data for the year 2013 and select relevant columns (state name + tax columns)
df_2013 = df3[df3['YearCode'] == 2013][['srcStateName'] + tax_columns]

# Verify if all the tax columns exist in the DataFrame for 2013
valid_columns_2013 = [col for col in tax_columns if col in df_2013.columns]
print(f"Valid columns for 2013: {valid_columns_2013}")  # This will give you the columns that are available in the data

# Group the data by state and aggregate the tax revenues by summing the columns
df_2013_aggregated = df_2013.groupby('srcStateName')[valid_columns_2013].sum()

# Plot the stacked bar chart for 2013
ax = df_2013_aggregated.plot(kind='bar', stacked=True, figsize=(12, 8), colormap='tab20')

# Customize the plot with labels and title
ax.set_xlabel('State')
ax.set_ylabel('Tax Revenue (in billions or appropriate units)')
ax.set_title('Stacked Tax Revenue by State (2013)')

# Rotate x-axis labels for better readability
plt.xticks(rotation=90)

# Add a legend for better understanding of the stacked bars
ax.legend(title='Tax Categories', bbox_to_anchor=(1.05, 1), loc='upper left')

# Adjust layout to avoid cutting off labels
plt.tight_layout()

# Show the plot
plt.show()

# Filter the data for the year 2014 and select relevant columns (state name + tax columns)
df_2014 = df3[df3['YearCode'] == 2014][['srcStateName'] + tax_columns]

# Verify if all the tax columns exist in the DataFrame for 2014
valid_columns_2014 = [col for col in tax_columns if col in df_2014.columns]
print(f"Valid columns for 2014: {valid_columns_2014}")  # This will give you the columns that are available in the data

# Group the data by state and aggregate the tax revenues by summing the columns
df_2014_aggregated = df_2014.groupby('srcStateName')[valid_columns_2014].sum()

# Plot the stacked bar chart for 2014
ax = df_2014_aggregated.plot(kind='bar', stacked=True, figsize=(12, 8), colormap='tab20')

# Customize the plot with labels and title
ax.set_xlabel('State')
ax.set_ylabel('Tax Revenue (in billions or appropriate units)')
ax.set_title('Stacked Tax Revenue by State (2014)')

# Rotate x-axis labels for better readability
plt.xticks(rotation=90)

# Add a legend for better understanding of the stacked bars
ax.legend(title='Tax Categories', bbox_to_anchor=(1.05, 1), loc='upper left')

# Adjust layout to avoid cutting off labels
plt.tight_layout()

# Show the plot
plt.show()

# Filter the data for the year 2015 and select relevant columns (state name + tax columns)
df_2015 = df3[df3['YearCode'] == 2015][['srcStateName'] + tax_columns]

# Verify if all the tax columns exist in the DataFrame for 2015
valid_columns_2015 = [col for col in tax_columns if col in df_2015.columns]
print(f"Valid columns for 2015: {valid_columns_2015}")  # This will give you the columns that are available in the data

# Group the data by state and aggregate the tax revenues by summing the columns
df_2015_aggregated = df_2015.groupby('srcStateName')[valid_columns_2015].sum()

# Plot the stacked bar chart for 2015
ax = df_2015_aggregated.plot(kind='bar', stacked=True, figsize=(12, 8), colormap='tab20')

# Customize the plot with labels and title
ax.set_xlabel('State')
ax.set_ylabel('Tax Revenue (in billions or appropriate units)')
ax.set_title('Stacked Tax Revenue by State (2015)')

# Rotate x-axis labels for better readability
plt.xticks(rotation=90)

# Add a legend for better understanding of the stacked bars
ax.legend(title='Tax Categories', bbox_to_anchor=(1.05, 1), loc='upper left')

# Adjust layout to avoid cutting off labels
plt.tight_layout()

# Show the plot
plt.show()

# Filter the data for the year 2016 and select relevant columns (state name + tax columns)
df_2016 = df3[df3['YearCode'] == 2016][['srcStateName'] + tax_columns]

# Verify if all the tax columns exist in the DataFrame for 2016
valid_columns_2016 = [col for col in tax_columns if col in df_2016.columns]
print(f"Valid columns for 2016: {valid_columns_2016}")  # This will give you the columns that are available in the data

# Group the data by state and aggregate the tax revenues by summing the columns
df_2016_aggregated = df_2016.groupby('srcStateName')[valid_columns_2016].sum()

# Plot the stacked bar chart for 2016
ax = df_2016_aggregated.plot(kind='bar', stacked=True, figsize=(12, 8), colormap='tab20')

# Customize the plot with labels and title
ax.set_xlabel('State')
ax.set_ylabel('Tax Revenue (in billions or appropriate units)')
ax.set_title('Stacked Tax Revenue by State (2016)')

# Rotate x-axis labels for better readability
plt.xticks(rotation=90)

# Add a legend for better understanding of the stacked bars
ax.legend(title='Tax Categories', bbox_to_anchor=(1.05, 1), loc='upper left')

# Adjust layout to avoid cutting off labels
plt.tight_layout()

# Show the plot
plt.show()

# Filter the data for the year 2017 and select relevant columns (state name + tax columns)
df_2017 = df3[df3['YearCode'] == 2017][['srcStateName'] + tax_columns]

# Verify if all the tax columns exist in the DataFrame for 2017
valid_columns_2017 = [col for col in tax_columns if col in df_2017.columns]
print(f"Valid columns for 2017: {valid_columns_2017}")  # This will give you the columns that are available in the data

# Group the data by state and aggregate the tax revenues by summing the columns
df_2017_aggregated = df_2017.groupby('srcStateName')[valid_columns_2017].sum()

# Plot the stacked bar chart for 2017
ax = df_2017_aggregated.plot(kind='bar', stacked=True, figsize=(12, 8), colormap='tab20')

# Customize the plot with labels and title
ax.set_xlabel('State')
ax.set_ylabel('Tax Revenue (in billions or appropriate units)')
ax.set_title('Stacked Tax Revenue by State (2017)')

# Rotate x-axis labels for better readability
plt.xticks(rotation=90)

# Add a legend for better understanding of the stacked bars
ax.legend(title='Tax Categories', bbox_to_anchor=(1.05, 1), loc='upper left')

# Adjust layout to avoid cutting off labels
plt.tight_layout()

# Show the plot
plt.show()

# Filter the data for the year 2018 and select relevant columns (state name + tax columns)
df_2018 = df3[df3['YearCode'] == 2018][['srcStateName'] + tax_columns]

# Verify if all the tax columns exist in the DataFrame for 2018
valid_columns_2018 = [col for col in tax_columns if col in df_2018.columns]
print(f"Valid columns for 2018: {valid_columns_2018}")  # This will give you the columns that are available in the data

# Group the data by state and aggregate the tax revenues by summing the columns
df_2018_aggregated = df_2018.groupby('srcStateName')[valid_columns_2018].sum()

# Plot the stacked bar chart for 2018
ax = df_2018_aggregated.plot(kind='bar', stacked=True, figsize=(12, 8), colormap='tab20')

# Customize the plot with labels and title
ax.set_xlabel('State')
ax.set_ylabel('Tax Revenue (in billions or appropriate units)')
ax.set_title('Stacked Tax Revenue by State (2018)')

# Rotate x-axis labels for better readability
plt.xticks(rotation=90)

# Add a legend for better understanding of the stacked bars
ax.legend(title='Tax Categories', bbox_to_anchor=(1.05, 1), loc='upper left')

# Adjust layout to avoid cutting off labels
plt.tight_layout()

# Show the plot
plt.show()

# Filter the data for the year 2019 and select relevant columns (state name + tax columns)
df_2019 = df3[df3['YearCode'] == 2019][['srcStateName'] + tax_columns]

# Verify if all the tax columns exist in the DataFrame for 2019
valid_columns_2019 = [col for col in tax_columns if col in df_2019.columns]
print(f"Valid columns for 2019: {valid_columns_2019}")  # This will give you the columns that are available in the data

# Group the data by state and aggregate the tax revenues by summing the columns
df_2019_aggregated = df_2019.groupby('srcStateName')[valid_columns_2019].sum()

# Plot the stacked bar chart for 2019
ax = df_2019_aggregated.plot(kind='bar', stacked=True, figsize=(12, 8), colormap='tab20')

# Customize the plot with labels and title
ax.set_xlabel('State')
ax.set_ylabel('Tax Revenue (in billions or appropriate units)')
ax.set_title('Stacked Tax Revenue by State (2019)')

# Rotate x-axis labels for better readability
plt.xticks(rotation=90)

# Add a legend for better understanding of the stacked bars
ax.legend(title='Tax Categories', bbox_to_anchor=(1.05, 1), loc='upper left')

# Adjust layout to avoid cutting off labels
plt.tight_layout()

# Show the plot
plt.show()

import pandas as pd

# Assuming df4 is your original DataFrame

# Define the related groups of columns to be aggregated (as given in your previous message)
tax_columns = [
    'Tax revenue', 'State own tax revenue', 'Taxes on income', 'Agricultural income',
    'Taxes on professions, trades, callings and employment', 'Taxes on property and capital transactions',
    'Land revenue', 'Stamps and registration fees', 'Urban immovable property tax',
    'Taxes on commodities and services', 'Sales tax', 'State sales tax or Value added tax (VAT)',
    'Central sales tax', 'Surcharge on sales tax', 'Receipts of turnover tax',
    'Other receipts of sales tax', 'State excise', 'Taxes on vehicles',
    'Taxes on goods and passengers', 'Taxes and duties on electricity', 'Entertainment tax',
    'Other taxes and duties', 'Share in central taxes', 'Corporation tax', 'Income tax',
    'Estate duty', 'Other taxes on income and expenditure', 'Taxes on wealth', 'Customs',
    'Union excise duties', 'Service tax', 'Other taxes and duties on commodities'
]

non_tax_columns = [
    'Non-tax revenue', 'State own non-tax revenue', 'Interest receipts', 'Dividends and profits',
    'State lotteries'
]

general_services_columns = [
    'General services', 'Social services', 'Education, sports, art and culture',
    'Medical and public health', 'Family welfare', 'Housing', 'Urban development',
    'Labour and employment', 'Social security and welfare', 'Water supply and sanitation',
    'Other social services taxes', 'Fiscal services'
]

economic_services_columns = [
    'Economic services', 'Crop husbandry', 'Animal husbandry', 'Fisheries',
    'Forestry and wildlife', 'Plantations', 'Co-operation', 'Other agricultural programmes',
    'Major and medium irrigation projects', 'Minor irrigation', 'Power', 'Petroleum',
    'Village and small industries', 'Industries', 'Ports and light houses', 'Road transport',
    'Tourism', 'Other economic sevices taxes'
]

grants_columns = [
    'Grants from the centre', 'State plan schemes', 'Advance release of plan assistance for natural calamities',
    'Central plan schemes', 'Centrally sponsored schemes', 'North eastern council (NEC) / Special plan scheme',
    'Non-plan grants', 'Statutory grants', 'Grants for relief on account of natural calamities',
    'Other non-plan grants'
]

gst_columns = [
    'State Goods and Services Tax (SGST)', 'Central Goods and Services Tax (CGST)',
    'Integrated Goods and Services Tax (IGST)', 'Sales tax on motor spirit and lubricants',
    'Medical, public health and family welfare', 'Goods and Services Tax (GST) compensation',
    'Value Added Tax (VAT) compensation', 'Central sales tax compensation', 'Compensation cess (code:0009)'
]

# Create a new DataFrame df5 by grouping and summing the columns within each defined group
df5 = pd.DataFrame()

# Sum the values across the groups
df5['Total Tax Revenue'] = df4[tax_columns].sum(axis=1)
df5['Total Non-Tax Revenue'] = df4[non_tax_columns].sum(axis=1)
df5['Total General Services'] = df4[general_services_columns].sum(axis=1)
df5['Total Economic Services'] = df4[economic_services_columns].sum(axis=1)
df5['Total Grants'] = df4[grants_columns].sum(axis=1)
df5['Total GST and Compensation'] = df4[gst_columns].sum(axis=1)

# Optionally, keep the original grouping for each individual category
for group, columns in [('Tax Revenue', tax_columns),
                       ('Non-Tax Revenue', non_tax_columns),
                       ('General Services', general_services_columns),
                       ('Economic Services', economic_services_columns),
                       ('Grants', grants_columns),
                       ('GST and Compensation', gst_columns)]:
    for col in columns:
        df5[f'{group}: {col}'] = df4[col]

# Include Year and State from the original dataframe
df5['YearCode'] = df4['YearCode']
df5['State'] = df4['srcStateName']

# Display only a few columns for review
df5_display = df5[['State', 'YearCode', 'Total Tax Revenue', 'Total Non-Tax Revenue', 'Total General Services', 'Total Economic Services']]

df5_display.head()

